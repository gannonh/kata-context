---
phase: 05-api-testing-layer
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - api/v1/contexts/[id]/messages.ts
  - api/v1/contexts/[id]/window.ts
autonomous: true

must_haves:
  truths:
    - "POST /api/v1/contexts/:id/messages appends messages to context"
    - "GET /api/v1/contexts/:id/messages returns paginated messages"
    - "GET /api/v1/contexts/:id/window returns token-budgeted messages"
    - "Empty context returns empty array (not error)"
    - "Budget exceeding total returns all messages"
  artifacts:
    - path: "api/v1/contexts/[id]/messages.ts"
      provides: "Message append and retrieval endpoints"
      exports: ["POST", "GET"]
    - path: "api/v1/contexts/[id]/window.ts"
      provides: "Token-budgeted window endpoint"
      exports: ["GET"]
  key_links:
    - from: "api/v1/contexts/[id]/messages.ts"
      to: "src/repositories/message.repository.ts"
      via: "MessageRepository.append() and findByContext()"
      pattern: "repository\\.(append|findByContext)"
    - from: "api/v1/contexts/[id]/window.ts"
      to: "src/repositories/message.repository.ts"
      via: "MessageRepository.getByTokenBudget()"
      pattern: "repository\\.getByTokenBudget"
---

<objective>
Implement REST endpoints for message operations and token-budgeted windowing.

Purpose: Expose MessageRepository operations for appending messages, paginated retrieval, and context window generation.
Output: Three working endpoints for message management.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-api-testing-layer/05-RESEARCH.md

@api/health.ts
@src/repositories/message.repository.ts
@src/api/validation/schemas.ts
@src/api/errors.ts
@src/api/responses.ts
@src/api/helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST and GET /api/v1/contexts/:id/messages endpoints</name>
  <files>api/v1/contexts/[id]/messages.ts</files>
  <action>
Create `api/v1/contexts/[id]/messages.ts` with named exports for POST and GET.

**Common setup:**
- Extract context ID using `extractContextId(pathname)`
- Validate UUID with `isValidUUID(id)` (return 400 if invalid)
- Create MessageRepository at module scope

**POST function (API-04):**
1. Parse JSON body with try/catch (return 400 on parse error)
2. Validate with `appendMessagesSchema.safeParse()` (return 400 with errors on failure)
3. Call `repository.append(id, result.data.messages)`
4. Catch RepositoryError with code "NOT_FOUND" -> return 404
5. Return `successResponse(201, { data: messages })` with appended messages

**GET function (API-05):**
1. Parse query params from URL: cursor, limit, order
2. Validate with `paginationSchema.safeParse()` (return 400 on failure)
3. Call `repository.findByContext(id, result.data)`
4. Return `successResponse(200, result)` with { data, nextCursor, hasMore }

Note: findByContext returns empty array for non-existent context (not error).

Requirements covered: API-04, API-05
  </action>
  <verify>
```bash
pnpm build
```
Test message operations:
```bash
# Create context first
ID=$(curl -s -X POST https://[preview-url]/api/v1/contexts \
  -H "Content-Type: application/json" \
  -d '{}' | jq -r '.data.id')

# Append messages
curl -X POST https://[preview-url]/api/v1/contexts/$ID/messages \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "user", "content": "Hello", "tokenCount": 5}]}'

# Get messages with pagination
curl "https://[preview-url]/api/v1/contexts/$ID/messages?limit=10"
```
  </verify>
  <done>POST appends messages with 201, GET returns paginated messages with 200.</done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/v1/contexts/:id/window endpoint</name>
  <files>api/v1/contexts/[id]/window.ts</files>
  <action>
Create `api/v1/contexts/[id]/window.ts` with GET export.

**GET function (API-06):**
1. Extract context ID using `extractContextId(pathname)`
2. Validate UUID with `isValidUUID(id)` (return 400 if invalid)
3. Parse `budget` query param from URL
4. Validate with `tokenBudgetSchema.safeParse({ budget })` (return 400 if missing or invalid)
5. Call `repository.getByTokenBudget(id, { budget: result.data.budget })`
6. Return `successResponse(200, { data: messages })`

Edge case handling (handled by repository):
- Non-existent context -> returns empty array
- Budget exceeds total tokens -> returns all messages
- Zero/negative budget -> returns empty array

Create MessageRepository at module scope.

Requirements covered: API-06, TEST-03 (edge cases)
  </action>
  <verify>
```bash
pnpm build
```
Test window endpoint:
```bash
# Use context with messages from Task 1
# Get window with budget
curl "https://[preview-url]/api/v1/contexts/$ID/window?budget=100"

# Test edge cases
curl "https://[preview-url]/api/v1/contexts/$ID/window?budget=1000000"  # Large budget
curl "https://[preview-url]/api/v1/contexts/00000000-0000-0000-0000-000000000000/window?budget=100"  # Non-existent

# Should 400 without budget
curl "https://[preview-url]/api/v1/contexts/$ID/window"
```
  </verify>
  <done>GET /window returns messages within token budget, handles edge cases gracefully.</done>
</task>

</tasks>

<verification>
After both tasks:
```bash
pnpm build && pnpm lint
```

Test complete message flow:
1. Create context
2. Append multiple messages with token counts
3. Retrieve with pagination (verify cursor works)
4. Get window with budget smaller than total (verify truncation)
5. Get window with budget larger than total (verify all returned)
</verification>

<success_criteria>
1. POST /api/v1/contexts/:id/messages appends messages with sequential versions
2. GET /api/v1/contexts/:id/messages returns paginated results with cursor
3. GET /api/v1/contexts/:id/window returns messages fitting within budget
4. Empty context returns empty array (200, not 404)
5. Large budget returns all messages
6. Missing budget parameter returns 400
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-testing-layer/05-03-SUMMARY.md`
</output>
