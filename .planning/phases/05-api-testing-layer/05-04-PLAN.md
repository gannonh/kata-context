---
phase: 05-api-testing-layer
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - src/api/__tests__/contexts.unit.test.ts
  - src/api/__tests__/messages.unit.test.ts
  - src/api/__tests__/contexts.integration.test.ts
  - src/api/__tests__/messages.integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Unit tests verify API logic with mocked repository"
    - "Integration tests verify full request-to-database flow"
    - "Token windowing edge cases are tested"
    - "All tests pass with pnpm test"
  artifacts:
    - path: "src/api/__tests__/contexts.unit.test.ts"
      provides: "Unit tests for context endpoints"
      min_lines: 80
    - path: "src/api/__tests__/messages.unit.test.ts"
      provides: "Unit tests for message endpoints"
      min_lines: 80
    - path: "src/api/__tests__/contexts.integration.test.ts"
      provides: "Integration tests for context endpoints"
      min_lines: 60
    - path: "src/api/__tests__/messages.integration.test.ts"
      provides: "Integration tests for message and window endpoints"
      min_lines: 100
  key_links:
    - from: "src/api/__tests__/*.unit.test.ts"
      to: "vitest"
      via: "vi.mock for repository mocking"
      pattern: "vi\\.mock"
    - from: "src/api/__tests__/*.integration.test.ts"
      to: "vitest.setup.ts"
      via: "setupTestDb/teardownTestDb"
      pattern: "setupTestDb|teardownTestDb"
---

<objective>
Create comprehensive test coverage for all API endpoints.

Purpose: Verify API handlers work correctly in isolation (unit) and with real database (integration).
Output: Unit and integration tests achieving full API coverage.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-api-testing-layer/05-RESEARCH.md

@vitest.setup.ts
@src/repositories/context.repository.test.ts
@src/repositories/message.repository.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit tests for API endpoints</name>
  <files>
    - src/api/__tests__/contexts.unit.test.ts
    - src/api/__tests__/messages.unit.test.ts
  </files>
  <action>
Create `src/api/__tests__/` directory.

**contexts.unit.test.ts:**
Mock ContextRepository and db client at top of file (vi.mock hoisting):
```typescript
vi.mock("../../../src/repositories/index.js", () => ({
  ContextRepository: vi.fn().mockImplementation(() => mockRepository),
}));
vi.mock("../../../src/db/client.js", () => ({ db: {} }));
```

Test cases for POST /api/v1/contexts:
- Creates context with valid input (name provided)
- Creates context with empty body (optional name)
- Returns 400 for invalid JSON
- Returns 400 for validation errors (name too long)
- Returns 500 and logs on repository error

Test cases for GET /api/v1/contexts/:id:
- Returns context when found
- Returns 404 when not found
- Returns 400 for invalid UUID format

Test cases for DELETE /api/v1/contexts/:id:
- Soft-deletes and returns context
- Returns 404 when not found
- Returns 400 for invalid UUID format

**messages.unit.test.ts:**
Mock MessageRepository similarly.

Test cases for POST /api/v1/contexts/:id/messages:
- Appends messages with valid input
- Returns 400 for invalid JSON
- Returns 400 for empty messages array
- Returns 400 for invalid message role
- Returns 404 when context not found (RepositoryError)

Test cases for GET /api/v1/contexts/:id/messages:
- Returns paginated messages
- Respects limit parameter
- Returns 400 for invalid pagination params

Test cases for GET /api/v1/contexts/:id/window:
- Returns messages within budget
- Returns 400 when budget missing
- Returns 400 when budget invalid (negative, non-number)

Requirements covered: TEST-01
  </action>
  <verify>
```bash
pnpm test src/api/__tests__/*.unit.test.ts
```
All unit tests pass.
  </verify>
  <done>Unit tests cover all endpoints with mocked repositories, all passing.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests with PGlite</name>
  <files>
    - src/api/__tests__/contexts.integration.test.ts
    - src/api/__tests__/messages.integration.test.ts
  </files>
  <action>
Integration tests call actual handlers with real PGlite database.

**Important:** Integration tests need to use the test database, not production. Create a test-specific module that imports handlers but overrides the db dependency.

Pattern from research - create Request objects and call exported handlers directly:
```typescript
const request = new Request("http://localhost/api/v1/contexts", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ name: "Test" }),
});
const response = await POST(request);
```

**contexts.integration.test.ts:**
Use beforeAll/afterAll with setupTestDb/teardownTestDb.
Clean contexts table in beforeEach.

Test full CRUD lifecycle:
- Create context -> verify in database
- Read context -> matches created
- Delete context -> returns deleted, subsequent read returns 404
- Create multiple contexts -> all retrievable

**messages.integration.test.ts:**
Test message operations with real database:
- Append single message -> verify version assigned
- Append multiple messages -> verify sequential versions
- Pagination with cursor -> verify continuation
- Token-budgeted window -> verify correct messages returned

**TEST-03 edge cases (in messages.integration.test.ts):**
- Empty context returns empty array (not 404)
- Budget exceeds total tokens -> returns all messages
- Budget of 1 -> returns at least one message (first always included)
- Zero budget -> returns empty array

**Challenge:** Handlers import `db` from `src/db/client.js` at module level. For integration tests, we need to override this with testDb.

**Solution approach:** Create test versions of handlers that accept db as parameter, OR use vi.mock to replace the db import with testDb for integration tests:
```typescript
vi.mock("../../../src/db/client.js", async () => {
  const { testDb } = await import("../../../vitest.setup.js");
  return { db: testDb };
});
```

Requirements covered: TEST-02, TEST-03
  </action>
  <verify>
```bash
pnpm test src/api/__tests__/*.integration.test.ts
```
All integration tests pass against PGlite.
  </verify>
  <done>Integration tests verify full request-to-database flow, edge cases covered.</done>
</task>

<task type="auto">
  <name>Task 3: Verify complete test suite</name>
  <files>None (verification only)</files>
  <action>
Run full test suite to ensure no regressions:
```bash
pnpm test
```

Verify test count increased from Phase 4 baseline (31 tests).

Check test output shows:
- contexts.unit.test.ts (9+ tests)
- messages.unit.test.ts (9+ tests)
- contexts.integration.test.ts (4+ tests)
- messages.integration.test.ts (8+ tests)
- Plus existing repository tests (31)

Total should be ~61+ tests.

If any failures, fix before proceeding.
  </action>
  <verify>
```bash
pnpm test
```
All tests pass. No regressions in existing tests.
  </verify>
  <done>Full test suite passes with 60+ tests.</done>
</task>

</tasks>

<verification>
After all tasks:
```bash
pnpm test
pnpm build
pnpm lint
```
All commands succeed with zero errors.
</verification>

<success_criteria>
1. Unit tests mock repository layer and test API logic in isolation
2. Integration tests use PGlite and verify full stack
3. Token windowing edge cases covered (empty, overflow, zero)
4. All new tests pass
5. No regression in existing 31 repository tests
6. Total test count ~60+
</success_criteria>

<output>
After completion, create `.planning/phases/05-api-testing-layer/05-04-SUMMARY.md`
</output>
