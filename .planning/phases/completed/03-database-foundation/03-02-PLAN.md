---
phase: 03-database-foundation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/db/migrations/*.sql
  - api/health.ts
autonomous: false
user_setup:
  - service: neon
    why: "Database must exist before migration can run"
    env_vars:
      - name: DATABASE_URL
        source: "Neon Console -> Connection Details -> Connection string (pooled)"
    dashboard_config:
      - task: "Verify pgvector extension is enabled"
        location: "Neon Console -> SQL Editor -> Run: SELECT * FROM pg_extension WHERE extname = 'vector';"

must_haves:
  truths:
    - "Developer can run pnpm db:migrate and see tables created"
    - "Health endpoint queries database and returns connection status"
    - "pgvector extension is verified as enabled"
    - "Connection uses pooled endpoint (hostname contains -pooler)"
  artifacts:
    - path: "src/db/migrations/0000_*.sql"
      provides: "Initial database migration"
      contains: "CREATE TABLE"
    - path: "api/health.ts"
      provides: "Health endpoint with database check"
      contains: "database"
  key_links:
    - from: "api/health.ts"
      to: "src/db/client.ts"
      via: "db import"
      pattern: "import.*db.*from"
    - from: "src/db/migrations/*.sql"
      to: "contexts"
      via: "CREATE TABLE"
      pattern: "CREATE TABLE.*contexts"
---

<objective>
Generate and run initial database migration, then update health endpoint to verify database connectivity.

Purpose: Validates the complete database setup by creating actual tables and confirming connectivity from the application.
Output: Working database with contexts and messages tables, health endpoint reporting database status.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/SUMMARY.md

# From Plan 01
@src/db/schema/index.ts
@src/db/client.ts
@drizzle.config.ts
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Provision Neon database</name>
  <action>
User must provision Neon PostgreSQL database before migration can run.
  </action>
  <instructions>
1. Go to https://console.neon.tech
2. Create a new project (or use existing):
   - Project name: kata-context
   - Region: Choose closest to your users
   - Postgres version: 17 (latest)

3. After project creation, enable pgvector:
   - Go to SQL Editor
   - Run: `CREATE EXTENSION IF NOT EXISTS vector;`
   - Verify: `SELECT * FROM pg_extension WHERE extname = 'vector';`

4. Get the pooled connection string:
   - Go to Connection Details
   - Select "Pooled connection"
   - Copy the connection string (should contain `-pooler` in hostname)
   - Format: `postgresql://user:password@ep-xxx-pooler.region.aws.neon.tech/dbname?sslmode=require`

5. Set environment variable locally:
   - Create `.env` file (it's in .gitignore)
   - Add: `DATABASE_URL=<your-pooled-connection-string>`

6. Set environment variable in Vercel:
   - Go to Vercel project settings -> Environment Variables
   - Add DATABASE_URL for Production, Preview, and Development
  </instructions>
  <verify>
User confirms: "DATABASE_URL is set locally and in Vercel"
  </verify>
  <done>Neon database provisioned with pgvector, pooled connection string configured in environment.</done>
</task>

<task type="auto">
  <name>Task 2: Generate and run initial migration</name>
  <files>src/db/migrations/*.sql</files>
  <action>
Generate migration from schema:
```bash
pnpm db:generate
```

This creates a migration file in src/db/migrations/ based on the Drizzle schema.
The migration should include:
- CREATE TABLE contexts (all columns from schema)
- CREATE TABLE messages (all columns including vector type)
- CREATE INDEX for context_version and deleted_at
- CREATE UNIQUE CONSTRAINT for context_id + version

Review the generated migration to verify:
1. Tables have correct column types
2. Foreign key from messages.context_id to contexts.id exists
3. Indexes are created
4. Vector column uses correct dimension (1536)

Run the migration:
```bash
pnpm db:migrate
```

Note: If the migration fails with "extension vector is not available", the user needs to run `CREATE EXTENSION vector;` in Neon SQL Editor first (should have been done in Task 1).
  </action>
  <verify>
`pnpm db:migrate` completes successfully.
Migration file exists: `ls src/db/migrations/*.sql`
Tables exist in database (verify in Neon Console -> Tables).
  </verify>
  <done>Migration generated and applied, contexts and messages tables exist in Neon database.</done>
</task>

<task type="auto">
  <name>Task 3: Update health endpoint with database connectivity check</name>
  <files>api/health.ts</files>
  <action>
Update api/health.ts to include database connectivity check:

```typescript
import { db, pool } from "../src/db/client.js";
import { sql } from "drizzle-orm";

interface HealthResponse {
  status: "healthy" | "degraded" | "unhealthy";
  timestamp: string;
  version: string;
  checks: {
    database: {
      status: "connected" | "disconnected";
      latencyMs?: number;
      pooled?: boolean;
      error?: string;
    };
  };
}

export async function GET(_request: Request): Promise<Response> {
  const startTime = performance.now();
  const response: HealthResponse = {
    status: "healthy",
    timestamp: new Date().toISOString(),
    version: process.env.npm_package_version ?? "0.1.0",
    checks: {
      database: {
        status: "disconnected",
      },
    },
  };

  try {
    // Simple query to verify connection
    await db.execute(sql`SELECT 1`);

    const latencyMs = Math.round(performance.now() - startTime);

    // Check if using pooled connection
    const connectionString = process.env.DATABASE_URL ?? "";
    const isPooled = connectionString.includes("-pooler");

    response.checks.database = {
      status: "connected",
      latencyMs,
      pooled: isPooled,
    };
  } catch (error) {
    response.status = "unhealthy";
    response.checks.database = {
      status: "disconnected",
      error: error instanceof Error ? error.message : "Unknown database error",
    };

    return Response.json(response, { status: 503 });
  }

  return Response.json(response);
}
```

Key points:
- Uses async handler for database query
- Includes latency measurement for observability
- Warns if not using pooled connection
- Returns 503 if database is unreachable
- Maintains backward compatibility with status field
  </action>
  <verify>
`pnpm run build` compiles without errors.
Local test: `pnpm vercel dev` then `curl http://localhost:3000/health` returns database status.
Database check shows `"status": "connected"` and `"pooled": true`.
  </verify>
  <done>Health endpoint queries database and returns connection status with latency.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete database foundation with migration and health check</what-built>
  <how-to-verify>
1. Verify tables exist in Neon:
   - Go to Neon Console -> Tables
   - Confirm `contexts` and `messages` tables are listed
   - Confirm messages table has `embedding` column (vector type)

2. Verify pgvector extension:
   - Go to Neon Console -> SQL Editor
   - Run: `SELECT * FROM pg_extension WHERE extname = 'vector';`
   - Should return one row

3. Verify health endpoint locally:
   ```bash
   pnpm vercel dev
   curl http://localhost:3000/health | jq
   ```
   Expected response includes:
   ```json
   {
     "status": "healthy",
     "checks": {
       "database": {
         "status": "connected",
         "pooled": true
       }
     }
   }
   ```

4. Verify pooled connection:
   - Check that `pooled: true` in health response
   - If false, verify DATABASE_URL contains `-pooler` in hostname

5. Optional: Deploy to Vercel and verify production:
   ```bash
   vercel --prod
   curl https://your-app.vercel.app/health | jq
   ```
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Phase 3 success criteria from ROADMAP.md:
1. [x] Developer can run `pnpm db:migrate` and see tables created in Neon dashboard
2. [x] Health endpoint queries database and returns connection status
3. [x] Drizzle schema compiles with full TypeScript type inference (verified in Plan 01)
4. [x] Connection pooling uses pooled endpoint (hostname contains -pooler)
5. [x] pgvector extension is enabled (verified via SQL query)
</verification>

<success_criteria>
- Migration file generated in src/db/migrations/
- Migration successfully applied to Neon database
- contexts and messages tables exist with all columns
- pgvector extension enabled (SELECT confirms)
- Health endpoint returns database connection status
- Health endpoint shows `pooled: true` when using correct connection string
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-database-foundation/03-02-SUMMARY.md`
</output>
