---
phase: 04-repository-layer
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/repositories/message.repository.ts
  - src/repositories/message.repository.test.ts
  - src/repositories/index.ts
autonomous: true

must_haves:
  truths:
    - "Messages appended to a context have automatically assigned sequential version numbers"
    - "Batch insert is atomic - all messages succeed or all fail"
    - "Context counters (messageCount, totalTokens, latestVersion) update atomically"
    - "Cursor-based pagination returns consistent results"
    - "Token-budgeted retrieval stops at budget and returns in chronological order"
  artifacts:
    - path: "src/repositories/message.repository.ts"
      provides: "Message CRUD operations with pagination and windowing"
      exports: ["MessageRepository"]
    - path: "src/repositories/message.repository.test.ts"
      provides: "Comprehensive tests for message operations"
      min_lines: 150
  key_links:
    - from: "src/repositories/message.repository.ts"
      to: "src/db/schema/messages.ts"
      via: "Drizzle query builder"
      pattern: "from\\(messages\\)"
    - from: "src/repositories/message.repository.ts"
      to: "src/db/schema/contexts.ts"
      via: "Transaction with FOR UPDATE"
      pattern: "for\\(['\"]update['\"]\\)"
    - from: "src/repositories/message.repository.ts"
      to: "src/repositories/helpers.ts"
      via: "import notDeleted"
      pattern: "notDeleted\\(messages\\)"
---

<objective>
Create MessageRepository with batch insert, cursor pagination, and token-budgeted windowing.

Purpose: Completes the repository layer (DATA-03, DATA-04, DATA-06) with atomic operations and efficient retrieval patterns.

Output: Working MessageRepository with append/findByContext/getByTokenBudget methods, tested against PGlite.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-repository-layer/04-RESEARCH.md
@.planning/phases/04-repository-layer/04-01-SUMMARY.md
@src/db/schema/contexts.ts
@src/db/schema/messages.ts
@src/repositories/types.ts
@src/repositories/helpers.ts
@src/repositories/context.repository.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MessageRepository</name>
  <files>src/repositories/message.repository.ts, src/repositories/types.ts, src/repositories/index.ts</files>
  <action>
1. Update `src/repositories/types.ts` to add message input types:

```typescript
// Add after existing types:

import type { Message, NewMessage } from '../db/schema/index.js';

// Message input - what callers provide when appending messages
export type AppendMessageInput = Pick<NewMessage, 'role' | 'content' | 'tokenCount'> & {
  toolCallId?: string;
  toolName?: string;
  model?: string;
};

// Pagination options
export interface PaginationOptions {
  cursor?: number;   // version to start after
  limit?: number;    // max messages to return (default 50)
  order?: 'asc' | 'desc';  // version order (default 'asc')
}

// Token budget options
export interface TokenBudgetOptions {
  budget: number;  // max tokens to include
}
```

2. Create `src/repositories/message.repository.ts`:

```typescript
import { eq, and, gt, lt, asc, desc, sql } from 'drizzle-orm';
import type { NodePgDatabase } from 'drizzle-orm/node-postgres';
import type { PgliteDatabase } from 'drizzle-orm/pglite';
import { messages, type Message, contexts } from '../db/schema/index.js';
import type { AppendMessageInput, PaginatedResult, PaginationOptions, TokenBudgetOptions } from './types.js';
import { notDeleted, handleDatabaseError } from './helpers.js';
import { RepositoryError } from './types.js';
import * as schema from '../db/schema/index.js';

type Database = NodePgDatabase<typeof schema> | PgliteDatabase<typeof schema>;

export class MessageRepository {
  constructor(private db: Database) {}

  // DATA-03: Append messages to context (batch insert with sequence assignment)
  // Uses transaction with FOR UPDATE to prevent race conditions
  async append(contextId: string, newMessages: AppendMessageInput[]): Promise<Message[]> {
    if (newMessages.length === 0) {
      return [];
    }

    try {
      return await this.db.transaction(async (tx) => {
        // Lock context row and get current latest version
        const [context] = await tx
          .select({
            id: contexts.id,
            latestVersion: contexts.latestVersion
          })
          .from(contexts)
          .where(and(
            eq(contexts.id, contextId),
            notDeleted(contexts)
          ))
          .for('update');

        if (!context) {
          throw new RepositoryError(`Context not found: ${contextId}`, 'NOT_FOUND');
        }

        // Assign sequential versions starting after current latest
        let nextVersion = context.latestVersion;
        const messagesWithVersions = newMessages.map(msg => ({
          contextId,
          version: ++nextVersion,
          role: msg.role,
          content: msg.content,
          tokenCount: msg.tokenCount ?? null,
          toolCallId: msg.toolCallId ?? null,
          toolName: msg.toolName ?? null,
          model: msg.model ?? null,
        }));

        // Batch insert all messages
        const inserted = await tx
          .insert(messages)
          .values(messagesWithVersions)
          .returning();

        // Calculate total new tokens (null-safe)
        const totalNewTokens = inserted.reduce((sum, m) => sum + (m.tokenCount ?? 0), 0);

        // Atomically update context counters
        await tx
          .update(contexts)
          .set({
            messageCount: sql`${contexts.messageCount} + ${inserted.length}`,
            totalTokens: sql`${contexts.totalTokens} + ${totalNewTokens}`,
            latestVersion: nextVersion,
            updatedAt: new Date(),
          })
          .where(eq(contexts.id, contextId));

        return inserted;
      });
    } catch (error) {
      if (error instanceof RepositoryError) throw error;
      handleDatabaseError(error);
    }
  }

  // DATA-04: Retrieve messages with cursor-based pagination
  async findByContext(
    contextId: string,
    options: PaginationOptions = {}
  ): Promise<PaginatedResult<Message>> {
    const { cursor, limit = 50, order = 'asc' } = options;

    // Fetch one extra to determine if there are more
    const fetchLimit = limit + 1;

    // Build where conditions
    const conditions = [
      eq(messages.contextId, contextId),
      notDeleted(messages),
    ];

    // Add cursor condition if provided
    if (cursor !== undefined) {
      conditions.push(
        order === 'asc'
          ? gt(messages.version, cursor)
          : lt(messages.version, cursor)
      );
    }

    const results = await this.db
      .select()
      .from(messages)
      .where(and(...conditions))
      .orderBy(order === 'asc' ? asc(messages.version) : desc(messages.version))
      .limit(fetchLimit);

    const hasMore = results.length > limit;
    const data = hasMore ? results.slice(0, limit) : results;
    const nextCursor = hasMore && data.length > 0
      ? data[data.length - 1].version
      : null;

    return { data, nextCursor, hasMore };
  }

  // DATA-06: Token-budgeted windowing (retrieve last N tokens worth of messages)
  // Returns messages in chronological order (oldest first)
  async getByTokenBudget(
    contextId: string,
    options: TokenBudgetOptions
  ): Promise<Message[]> {
    const { budget } = options;

    if (budget <= 0) {
      return [];
    }

    // Fetch messages newest-first to find the window
    const allMessages = await this.db
      .select()
      .from(messages)
      .where(and(
        eq(messages.contextId, contextId),
        notDeleted(messages)
      ))
      .orderBy(desc(messages.version));

    // Accumulate until budget exceeded
    const result: Message[] = [];
    let tokensUsed = 0;

    for (const msg of allMessages) {
      const msgTokens = msg.tokenCount ?? 0;

      // Always include at least one message, then check budget
      if (tokensUsed + msgTokens > budget && result.length > 0) {
        break;
      }

      result.push(msg);
      tokensUsed += msgTokens;
    }

    // Return in chronological order (oldest first)
    return result.reverse();
  }

  // Helper: Get single message by context and version
  async findByVersion(contextId: string, version: number): Promise<Message | null> {
    const [message] = await this.db
      .select()
      .from(messages)
      .where(and(
        eq(messages.contextId, contextId),
        eq(messages.version, version),
        notDeleted(messages)
      ));

    return message ?? null;
  }
}
```

3. Update `src/repositories/index.ts` to export MessageRepository:

```typescript
export * from './types.js';
export * from './helpers.js';
export { ContextRepository } from './context.repository.js';
export { MessageRepository } from './message.repository.js';
```

KEY PATTERNS:
- Transaction with `for('update')` locks the context row to prevent race conditions
- Version assignment is sequential: latestVersion + 1, +2, etc.
- Atomic counter updates use `sql\`column + value\`` pattern
- Token windowing fetches newest-first, then reverses for chronological order
- Cursor pagination fetches limit+1 to detect hasMore without extra query
  </action>
  <verify>
- TypeScript compiles: `pnpm tsc --noEmit`
- MessageRepository exports from index.ts
- No runtime errors when importing: `node -e "import('./src/repositories/index.js')"`
  </verify>
  <done>MessageRepository implemented with append/findByContext/getByTokenBudget methods</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive MessageRepository tests</name>
  <files>src/repositories/message.repository.test.ts</files>
  <action>
Create `src/repositories/message.repository.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { setupTestDb, teardownTestDb, testDb } from '../../vitest.setup.js';
import { ContextRepository } from './context.repository.js';
import { MessageRepository } from './message.repository.js';
import { RepositoryError } from './types.js';
import { contexts, messages } from '../db/schema/index.js';

describe('MessageRepository', () => {
  let contextRepo: ContextRepository;
  let messageRepo: MessageRepository;

  beforeAll(async () => {
    await setupTestDb();
    contextRepo = new ContextRepository(testDb);
    messageRepo = new MessageRepository(testDb);
  });

  afterAll(async () => {
    await teardownTestDb();
  });

  beforeEach(async () => {
    // Clean in correct order (messages first due to FK)
    await testDb.delete(messages);
    await testDb.delete(contexts);
  });

  describe('append', () => {
    it('assigns sequential version numbers', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });

      const inserted = await messageRepo.append(ctx.id, [
        { role: 'user', content: 'Hello', tokenCount: 5 },
        { role: 'assistant', content: 'Hi there!', tokenCount: 10 },
      ]);

      expect(inserted).toHaveLength(2);
      expect(inserted[0].version).toBe(1);
      expect(inserted[1].version).toBe(2);
    });

    it('continues version sequence from existing messages', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });

      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 5 },
      ]);

      const second = await messageRepo.append(ctx.id, [
        { role: 'assistant', content: 'Second', tokenCount: 10 },
      ]);

      expect(second[0].version).toBe(2);
    });

    it('updates context counters atomically', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });

      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'Hello', tokenCount: 5 },
        { role: 'assistant', content: 'Hi!', tokenCount: 10 },
      ]);

      const updated = await contextRepo.findById(ctx.id);
      expect(updated?.messageCount).toBe(2);
      expect(updated?.totalTokens).toBe(15);
      expect(updated?.latestVersion).toBe(2);
    });

    it('handles null tokenCount', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });

      const inserted = await messageRepo.append(ctx.id, [
        { role: 'user', content: 'No tokens' },  // tokenCount omitted
      ]);

      expect(inserted[0].tokenCount).toBeNull();

      const updated = await contextRepo.findById(ctx.id);
      expect(updated?.totalTokens).toBe(0);  // null treated as 0
    });

    it('throws NOT_FOUND for non-existent context', async () => {
      await expect(
        messageRepo.append('00000000-0000-0000-0000-000000000000', [
          { role: 'user', content: 'Hello', tokenCount: 5 },
        ])
      ).rejects.toThrow(RepositoryError);
    });

    it('throws NOT_FOUND for soft-deleted context', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await contextRepo.softDelete(ctx.id);

      await expect(
        messageRepo.append(ctx.id, [
          { role: 'user', content: 'Hello', tokenCount: 5 },
        ])
      ).rejects.toThrow(RepositoryError);
    });

    it('returns empty array for empty input', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      const result = await messageRepo.append(ctx.id, []);
      expect(result).toEqual([]);
    });

    it('stores optional fields', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });

      const inserted = await messageRepo.append(ctx.id, [
        {
          role: 'tool',
          content: '{"result": 42}',
          tokenCount: 8,
          toolCallId: 'call_123',
          toolName: 'calculator',
          model: 'gpt-4',
        },
      ]);

      expect(inserted[0].toolCallId).toBe('call_123');
      expect(inserted[0].toolName).toBe('calculator');
      expect(inserted[0].model).toBe('gpt-4');
    });
  });

  describe('findByContext', () => {
    it('returns messages in ascending version order by default', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 5 },
        { role: 'assistant', content: 'Second', tokenCount: 10 },
        { role: 'user', content: 'Third', tokenCount: 5 },
      ]);

      const result = await messageRepo.findByContext(ctx.id);

      expect(result.data).toHaveLength(3);
      expect(result.data[0].content).toBe('First');
      expect(result.data[2].content).toBe('Third');
      expect(result.hasMore).toBe(false);
      expect(result.nextCursor).toBeNull();
    });

    it('supports descending order', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 5 },
        { role: 'assistant', content: 'Second', tokenCount: 10 },
      ]);

      const result = await messageRepo.findByContext(ctx.id, { order: 'desc' });

      expect(result.data[0].content).toBe('Second');
      expect(result.data[1].content).toBe('First');
    });

    it('paginates with cursor', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'M1', tokenCount: 5 },
        { role: 'user', content: 'M2', tokenCount: 5 },
        { role: 'user', content: 'M3', tokenCount: 5 },
        { role: 'user', content: 'M4', tokenCount: 5 },
        { role: 'user', content: 'M5', tokenCount: 5 },
      ]);

      // First page
      const page1 = await messageRepo.findByContext(ctx.id, { limit: 2 });
      expect(page1.data).toHaveLength(2);
      expect(page1.data[0].content).toBe('M1');
      expect(page1.data[1].content).toBe('M2');
      expect(page1.hasMore).toBe(true);
      expect(page1.nextCursor).toBe(2);

      // Second page using cursor
      const page2 = await messageRepo.findByContext(ctx.id, {
        limit: 2,
        cursor: page1.nextCursor!
      });
      expect(page2.data).toHaveLength(2);
      expect(page2.data[0].content).toBe('M3');
      expect(page2.data[1].content).toBe('M4');
      expect(page2.hasMore).toBe(true);

      // Third page (last)
      const page3 = await messageRepo.findByContext(ctx.id, {
        limit: 2,
        cursor: page2.nextCursor!
      });
      expect(page3.data).toHaveLength(1);
      expect(page3.data[0].content).toBe('M5');
      expect(page3.hasMore).toBe(false);
      expect(page3.nextCursor).toBeNull();
    });

    it('returns empty for non-existent context', async () => {
      const result = await messageRepo.findByContext('00000000-0000-0000-0000-000000000000');
      expect(result.data).toHaveLength(0);
      expect(result.hasMore).toBe(false);
    });
  });

  describe('getByTokenBudget', () => {
    it('returns messages fitting within budget in chronological order', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 10 },
        { role: 'assistant', content: 'Second', tokenCount: 20 },
        { role: 'user', content: 'Third', tokenCount: 15 },
        { role: 'assistant', content: 'Fourth', tokenCount: 25 },
      ]);

      // Budget of 40 should include Third (15) + Fourth (25) = 40
      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 40 });

      expect(result).toHaveLength(2);
      expect(result[0].content).toBe('Third');  // Chronological order
      expect(result[1].content).toBe('Fourth');
    });

    it('returns all messages when budget exceeds total', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 10 },
        { role: 'assistant', content: 'Second', tokenCount: 20 },
      ]);

      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 1000 });

      expect(result).toHaveLength(2);
      expect(result[0].content).toBe('First');
      expect(result[1].content).toBe('Second');
    });

    it('always includes at least one message', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'Large message', tokenCount: 100 },
      ]);

      // Budget smaller than single message
      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 10 });

      expect(result).toHaveLength(1);
      expect(result[0].content).toBe('Large message');
    });

    it('returns empty for empty context', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 100 });
      expect(result).toHaveLength(0);
    });

    it('returns empty for zero budget', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'Test', tokenCount: 10 },
      ]);

      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 0 });
      expect(result).toHaveLength(0);
    });

    it('handles null tokenCount as zero', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'No count' },  // null tokenCount
        { role: 'assistant', content: 'Has count', tokenCount: 50 },
      ]);

      // Budget of 50 should include both (0 + 50 = 50)
      const result = await messageRepo.getByTokenBudget(ctx.id, { budget: 50 });
      expect(result).toHaveLength(2);
    });
  });

  describe('findByVersion', () => {
    it('returns message at specific version', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      await messageRepo.append(ctx.id, [
        { role: 'user', content: 'First', tokenCount: 5 },
        { role: 'assistant', content: 'Second', tokenCount: 10 },
      ]);

      const msg = await messageRepo.findByVersion(ctx.id, 2);
      expect(msg?.content).toBe('Second');
    });

    it('returns null for non-existent version', async () => {
      const ctx = await contextRepo.create({ name: 'Test' });
      const msg = await messageRepo.findByVersion(ctx.id, 999);
      expect(msg).toBeNull();
    });
  });
});
```

TEST COVERAGE:
- append: Version sequencing, counter updates, error cases, optional fields
- findByContext: Ordering, pagination, cursor continuity, edge cases
- getByTokenBudget: Budget windowing, chronological order, edge cases
- findByVersion: Single message retrieval
  </action>
  <verify>
- `pnpm test src/repositories/message.repository.test.ts` - all tests pass
- `pnpm test src/repositories/` - all repository tests pass together
- No TypeScript errors: `pnpm tsc --noEmit`
  </verify>
  <done>MessageRepository fully tested with comprehensive coverage of all requirements</done>
</task>

</tasks>

<verification>
```bash
# All repository tests pass
pnpm test src/repositories/

# All project tests pass
pnpm test

# TypeScript compiles
pnpm tsc --noEmit

# Exports are correct
node -e "import('./src/repositories/index.js').then(m => console.log('Exports:', Object.keys(m)))"
```
</verification>

<success_criteria>
1. Messages appended have auto-assigned sequential version numbers
2. Batch insert is atomic (transaction with FOR UPDATE)
3. Context counters update atomically after message append
4. Cursor-based pagination returns consistent results across pages
5. Token-budgeted retrieval returns messages in chronological order
6. All tests pass against PGlite
7. TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-repository-layer/04-02-SUMMARY.md`
</output>
