---
phase: 04-repository-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - src/repositories/types.ts
  - src/repositories/helpers.ts
  - src/repositories/context.repository.ts
  - src/repositories/index.ts
  - src/repositories/context.repository.test.ts
  - vitest.setup.ts
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - "Developer can create a context and retrieve it by ID"
    - "Created context has auto-generated UUID, timestamps, and zero counters"
    - "Soft-deleted contexts are excluded from findById queries"
    - "Repository methods behave identically to production PostgreSQL"
  artifacts:
    - path: "src/repositories/context.repository.ts"
      provides: "Context CRUD operations"
      exports: ["ContextRepository"]
    - path: "src/repositories/types.ts"
      provides: "Repository result types and input types"
      exports: ["CreateContextInput", "RepositoryError"]
    - path: "src/repositories/helpers.ts"
      provides: "Shared repository utilities"
      exports: ["notDeleted", "handleDatabaseError"]
    - path: "vitest.setup.ts"
      provides: "PGlite test database setup"
      exports: ["setupTestDb", "teardownTestDb", "testDb"]
    - path: "vitest.config.ts"
      provides: "Vitest configuration with PGlite setup"
      contains: "setupFiles"
  key_links:
    - from: "src/repositories/context.repository.ts"
      to: "src/db/schema/contexts.ts"
      via: "Drizzle query builder"
      pattern: "from\\(contexts\\)"
    - from: "src/repositories/context.repository.ts"
      to: "src/repositories/helpers.ts"
      via: "import notDeleted"
      pattern: "notDeleted\\(contexts\\)"
    - from: "vitest.config.ts"
      to: "vitest.setup.ts"
      via: "setupFiles configuration"
      pattern: "setupFiles.*vitest\\.setup"
---

<objective>
Create the ContextRepository with type-safe CRUD operations and establish the testing infrastructure using PGlite.

Purpose: Provides the data access abstraction for contexts (DATA-01, DATA-02, DATA-05) and establishes patterns for MessageRepository.

Output: Working ContextRepository with create/findById/softDelete methods, tested against PGlite.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-repository-layer/04-RESEARCH.md
@src/db/schema/contexts.ts
@src/db/schema/messages.ts
@src/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install PGlite and create test setup</name>
  <files>package.json, pnpm-lock.yaml, vitest.setup.ts, vitest.config.ts</files>
  <action>
1. Install PGlite for testing:
   ```bash
   pnpm add -D @electric-sql/pglite
   ```

2. Create `vitest.setup.ts` in project root:
   - Import PGlite and drizzle-orm/pglite
   - Export `setupTestDb()` that creates PGlite instance and runs migrations
   - Export `teardownTestDb()` that closes the connection
   - Export `testDb` for use in tests
   - NOTE: PGlite is pure WASM PostgreSQL - no Docker required, real Postgres behavior

3. Update `vitest.config.ts` to use the setup file:
   - Add `setupFiles: ['./vitest.setup.ts']`
   - Ensure test timeout is reasonable (10s for migration setup)

Key patterns from research:
```typescript
import { PGlite } from '@electric-sql/pglite';
import { drizzle } from 'drizzle-orm/pglite';
import { migrate } from 'drizzle-orm/pglite/migrator';
import * as schema from './src/db/schema/index.js';

let testClient: PGlite;
export let testDb: ReturnType<typeof drizzle>;

export async function setupTestDb() {
  testClient = new PGlite();
  testDb = drizzle(testClient, { schema });
  await migrate(testDb, { migrationsFolder: './src/db/migrations' });
  return testDb;
}
```

IMPORTANT: The drizzle-orm/pglite import path is correct (not drizzle-pglite).
  </action>
  <verify>
- `pnpm list @electric-sql/pglite` shows package installed
- `vitest.setup.ts` exists with exported setup/teardown functions
- `vitest.config.ts` contains `setupFiles` referencing vitest.setup
- TypeScript compiles without errors: `pnpm tsc --noEmit`
- PGlite setup works with migrations:
  ```bash
  node -e "import('./vitest.setup.js').then(async m => { await m.setupTestDb(); await m.teardownTestDb(); console.log('PGlite setup verified'); })"
  ```
  </verify>
  <done>PGlite installed, test setup file created with migration support, and vitest.config.ts configured</done>
</task>

<task type="auto">
  <name>Task 2: Create repository types and helpers</name>
  <files>src/repositories/types.ts, src/repositories/helpers.ts, src/repositories/index.ts</files>
  <action>
1. Create `src/repositories/types.ts`:
   ```typescript
   import type { Context, NewContext, Message, NewMessage } from '../db/schema/index.js';

   // Input types - what callers provide (excludes auto-generated fields)
   export type CreateContextInput = Pick<NewContext, 'name'> & {
     metadata?: Record<string, unknown>;  // Future: stored in separate column
   };

   // Result types - what repository returns
   export type ContextWithMessageCount = Context;  // messageCount already in schema

   // Pagination
   export interface PaginatedResult<T> {
     data: T[];
     nextCursor: number | null;
     hasMore: boolean;
   }

   // Error handling
   export class RepositoryError extends Error {
     constructor(
       message: string,
       public readonly code: 'DUPLICATE' | 'NOT_FOUND' | 'FOREIGN_KEY' | 'DATABASE_ERROR',
       public readonly constraint?: string
     ) {
       super(message);
       this.name = 'RepositoryError';
     }
   }
   ```

2. Create `src/repositories/helpers.ts`:
   ```typescript
   import { isNull, type SQL } from 'drizzle-orm';
   import { DatabaseError } from 'pg';
   import { RepositoryError } from './types.js';

   // Soft delete filter - use with every query that should exclude deleted records
   export const notDeleted = <T extends { deletedAt: unknown }>(table: T): SQL =>
     isNull(table.deletedAt);

   // PostgreSQL error code handler
   export function handleDatabaseError(error: unknown): never {
     const pgError = (error as { cause?: unknown })?.cause;

     if (pgError instanceof DatabaseError) {
       switch (pgError.code) {
         case '23505': // unique_violation
           throw new RepositoryError('Duplicate entry', 'DUPLICATE', pgError.constraint ?? undefined);
         case '23503': // foreign_key_violation
           throw new RepositoryError('Referenced record not found', 'FOREIGN_KEY', pgError.constraint ?? undefined);
         default:
           throw new RepositoryError(`Database error: ${pgError.message}`, 'DATABASE_ERROR');
       }
     }

     throw error; // Re-throw unknown errors
   }
   ```

3. Create `src/repositories/index.ts`:
   ```typescript
   export * from './types.js';
   export * from './helpers.js';
   export { ContextRepository } from './context.repository.js';
   // MessageRepository export added in 04-02
   ```

NOTE: The helpers use drizzle-orm's isNull function which returns an SQL fragment.
NOTE: DatabaseError is imported from 'pg' package (already installed).
  </action>
  <verify>
- `src/repositories/types.ts` exports CreateContextInput, RepositoryError
- `src/repositories/helpers.ts` exports notDeleted, handleDatabaseError
- TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>Repository types and helper functions created with proper TypeScript types</done>
</task>

<task type="auto">
  <name>Task 3: Implement ContextRepository with tests</name>
  <files>src/repositories/context.repository.ts, src/repositories/context.repository.test.ts</files>
  <action>
1. Create `src/repositories/context.repository.ts`:

```typescript
import { eq, and } from 'drizzle-orm';
import type { NodePgDatabase } from 'drizzle-orm/node-postgres';
import type { PgliteDatabase } from 'drizzle-orm/pglite';
import { contexts, type Context, type NewContext } from '../db/schema/index.js';
import type { CreateContextInput } from './types.js';
import { notDeleted, handleDatabaseError } from './helpers.js';
import * as schema from '../db/schema/index.js';

// Support both production (node-postgres) and test (pglite) database types
type Database = NodePgDatabase<typeof schema> | PgliteDatabase<typeof schema>;

export class ContextRepository {
  constructor(private db: Database) {}

  // DATA-01: Create new context with optional name
  async create(input: CreateContextInput): Promise<Context> {
    try {
      const [context] = await this.db
        .insert(contexts)
        .values({
          name: input.name ?? null,
          // Auto-generated: id, createdAt, updatedAt, messageCount, totalTokens, latestVersion
        })
        .returning();

      return context;
    } catch (error) {
      handleDatabaseError(error);
    }
  }

  // DATA-02: Retrieve context by ID (excludes soft-deleted)
  async findById(id: string): Promise<Context | null> {
    const [context] = await this.db
      .select()
      .from(contexts)
      .where(and(
        eq(contexts.id, id),
        notDeleted(contexts)
      ));

    return context ?? null;
  }

  // DATA-05: Soft delete context (preserves history)
  async softDelete(id: string): Promise<Context | null> {
    const [context] = await this.db
      .update(contexts)
      .set({ deletedAt: new Date() })
      .where(and(
        eq(contexts.id, id),
        notDeleted(contexts)  // Can't delete already-deleted
      ))
      .returning();

    return context ?? null;
  }

  // Helper: Check if context exists and is not deleted (used by MessageRepository)
  async exists(id: string): Promise<boolean> {
    const context = await this.findById(id);
    return context !== null;
  }
}
```

2. Create `src/repositories/context.repository.test.ts`:

```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { setupTestDb, teardownTestDb, testDb } from '../../vitest.setup.js';
import { ContextRepository } from './context.repository.js';
import { contexts } from '../db/schema/index.js';

describe('ContextRepository', () => {
  let repository: ContextRepository;

  beforeAll(async () => {
    await setupTestDb();
    repository = new ContextRepository(testDb);
  });

  afterAll(async () => {
    await teardownTestDb();
  });

  beforeEach(async () => {
    // Clean tables between tests
    await testDb.delete(contexts);
  });

  describe('create', () => {
    it('creates a context with auto-generated fields', async () => {
      const ctx = await repository.create({ name: 'Test Context' });

      expect(ctx.id).toBeDefined();
      expect(ctx.id).toMatch(/^[0-9a-f-]{36}$/); // UUID format
      expect(ctx.name).toBe('Test Context');
      expect(ctx.messageCount).toBe(0);
      expect(ctx.totalTokens).toBe(0);
      expect(ctx.latestVersion).toBe(0);
      expect(ctx.createdAt).toBeInstanceOf(Date);
      expect(ctx.updatedAt).toBeInstanceOf(Date);
      expect(ctx.deletedAt).toBeNull();
    });

    it('creates a context without name', async () => {
      const ctx = await repository.create({});

      expect(ctx.id).toBeDefined();
      expect(ctx.name).toBeNull();
    });
  });

  describe('findById', () => {
    it('returns context by ID', async () => {
      const created = await repository.create({ name: 'Find Me' });
      const found = await repository.findById(created.id);

      expect(found).not.toBeNull();
      expect(found?.id).toBe(created.id);
      expect(found?.name).toBe('Find Me');
    });

    it('returns null for non-existent ID', async () => {
      const found = await repository.findById('00000000-0000-0000-0000-000000000000');
      expect(found).toBeNull();
    });

    it('excludes soft-deleted contexts', async () => {
      const ctx = await repository.create({ name: 'To Delete' });
      await repository.softDelete(ctx.id);

      const found = await repository.findById(ctx.id);
      expect(found).toBeNull();
    });
  });

  describe('softDelete', () => {
    it('sets deletedAt timestamp', async () => {
      const ctx = await repository.create({ name: 'Delete Me' });
      const deleted = await repository.softDelete(ctx.id);

      expect(deleted).not.toBeNull();
      expect(deleted?.deletedAt).toBeInstanceOf(Date);
    });

    it('returns null for non-existent ID', async () => {
      const deleted = await repository.softDelete('00000000-0000-0000-0000-000000000000');
      expect(deleted).toBeNull();
    });

    it('returns null when already deleted', async () => {
      const ctx = await repository.create({ name: 'Already Deleted' });
      await repository.softDelete(ctx.id);

      const secondDelete = await repository.softDelete(ctx.id);
      expect(secondDelete).toBeNull();
    });
  });

  describe('exists', () => {
    it('returns true for existing context', async () => {
      const ctx = await repository.create({ name: 'Exists' });
      expect(await repository.exists(ctx.id)).toBe(true);
    });

    it('returns false for non-existent context', async () => {
      expect(await repository.exists('00000000-0000-0000-0000-000000000000')).toBe(false);
    });

    it('returns false for soft-deleted context', async () => {
      const ctx = await repository.create({ name: 'Was Here' });
      await repository.softDelete(ctx.id);
      expect(await repository.exists(ctx.id)).toBe(false);
    });
  });
});
```

NOTE: Import path for vitest.setup.js uses relative path from test file location.
NOTE: Tests clean tables in beforeEach to ensure isolation.
  </action>
  <verify>
- `pnpm test src/repositories/context.repository.test.ts` - all tests pass
- Repository exports are available from `src/repositories/index.ts`
- TypeScript compiles: `pnpm tsc --noEmit`
  </verify>
  <done>ContextRepository implemented with create/findById/softDelete/exists methods, all tests passing</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
pnpm test

# TypeScript compiles without errors
pnpm tsc --noEmit

# Repository exports are correct
node -e "import('./src/repositories/index.js').then(m => console.log(Object.keys(m)))"
```
</verification>

<success_criteria>
1. PGlite installed and test setup working
2. vitest.config.ts configured with setupFiles pointing to vitest.setup.ts
3. ContextRepository.create() returns context with auto-generated UUID and timestamps
4. ContextRepository.findById() excludes soft-deleted contexts
5. ContextRepository.softDelete() sets deletedAt timestamp
6. All tests pass against PGlite (real PostgreSQL behavior)
7. TypeScript compilation succeeds with full type inference
</success_criteria>

<output>
After completion, create `.planning/phases/04-repository-layer/04-01-SUMMARY.md`
</output>
