---
phase: 06-infrastructure-policy-foundation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/repositories/types.ts
  - src/repositories/context.repository.ts
  - src/repositories/context.repository.test.ts
  - src/token-counting/index.test.ts
  - src/validation/policy.test.ts
  - src/api/validation/schemas.ts
autonomous: true

must_haves:
  truths:
    - "Context can be created with custom policyConfig that persists and is returned on findById"
    - "Context created without policyConfig returns null policyConfig (application resolves defaults)"
    - "resolvePolicy merges partial config with defaults correctly"
    - "Token counting returns consistent integer results for strings"
    - "All policy fields (threshold, preserveRecentCount, enabled) are validated and bounded"
  artifacts:
    - path: "src/repositories/types.ts"
      provides: "Updated CreateContextInput with optional policyConfig"
      contains: "policyConfig"
    - path: "src/repositories/context.repository.ts"
      provides: "Context create accepting and persisting policyConfig"
      contains: "policyConfig"
    - path: "src/repositories/context.repository.test.ts"
      provides: "Tests for policy config CRUD"
      contains: "policyConfig"
    - path: "src/validation/policy.test.ts"
      provides: "Tests for policy schema validation and defaults"
      contains: "resolvePolicy"
    - path: "src/token-counting/index.test.ts"
      provides: "Tests for token counting utility"
      contains: "countMessageTokens"
  key_links:
    - from: "src/repositories/context.repository.ts"
      to: "src/db/schema/contexts.ts"
      via: "policyConfig column in insert values"
      pattern: "policyConfig.*input\\.policyConfig"
    - from: "src/repositories/types.ts"
      to: "src/validation/policy.ts"
      via: "PolicyConfig type import"
      pattern: "import.*PolicyConfig.*from.*validation/policy"
    - from: "src/api/validation/schemas.ts"
      to: "src/validation/policy.ts"
      via: "policyConfigSchema reuse in API validation"
      pattern: "policyConfig"
---

<objective>
Wire policy config into the repository layer and prove all Phase 6 requirements with tests.

Purpose: Complete the data flow from API input through validation to database storage, and verify token counting, policy defaults, and policy persistence work correctly.
Output: Updated repository accepting policyConfig, comprehensive tests for all new functionality, API schema updated.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/pending/06-infrastructure-policy-foundation/06-RESEARCH.md
@.planning/phases/pending/06-infrastructure-policy-foundation/06-01-SUMMARY.md
@src/repositories/types.ts
@src/repositories/context.repository.ts
@src/repositories/context.repository.test.ts
@src/repositories/helpers.ts
@src/validation/policy.ts
@src/token-counting/index.ts
@src/api/validation/schemas.ts
@src/db/schema/contexts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update repository types, context repository, and API validation schema</name>
  <files>
    src/repositories/types.ts
    src/repositories/context.repository.ts
    src/api/validation/schemas.ts
  </files>
  <action>
1. Update `src/repositories/types.ts`:
   - Import `type PolicyConfig` from `"../validation/policy.js"`
   - Update `CreateContextInput` to include `policyConfig?: PolicyConfig`
   - Remove the `metadata?: Record<string, unknown>` comment/field if still present (it was a future placeholder)

2. Update `src/repositories/context.repository.ts` `create()` method:
   - In the `.values({})` call, add `policyConfig: input.policyConfig ?? null`
   - This passes the validated policy config through to the JSONB column
   - No changes to `findById` or `softDelete` needed; Drizzle returns all columns including the new JSONB column automatically

3. Update `src/api/validation/schemas.ts`:
   - Import `policyConfigSchema` from `"../validation/policy.js"`
   - Add `policyConfig` as an optional field to `createContextSchema`:
     ```typescript
     policyConfig: policyConfigSchema.optional(),
     ```
   - This enables API callers to pass policy config when creating contexts

Important: The repository stores whatever validated PolicyConfig it receives (or null). Default resolution happens at the application/API layer via `resolvePolicy()`, not in the repository. This keeps the repository as a clean data access layer.
  </action>
  <verify>
    - `pnpm build` compiles without errors
    - `pnpm lint` passes
  </verify>
  <done>
    - `CreateContextInput` includes optional `policyConfig` field typed as `PolicyConfig`
    - `ContextRepository.create()` passes policyConfig to insert
    - `createContextSchema` accepts optional policyConfig in API validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tests for token counting, policy validation, and policy persistence</name>
  <files>
    src/token-counting/index.test.ts
    src/validation/policy.test.ts
    src/repositories/context.repository.test.ts
  </files>
  <action>
1. Create `src/token-counting/index.test.ts`:
   - Test `countMessageTokens` returns a positive integer for non-empty strings
   - Test `countMessageTokens` returns 0 for empty string
   - Test consistency: same input always produces same output
   - Test with a known string (e.g., "hello world" should return a stable count)
   - Import from `"./index.js"`

2. Create `src/validation/policy.test.ts`:
   - Test `resolvePolicy({})` returns `{ threshold: 0.8, preserveRecentCount: 10, enabled: true }`
   - Test `resolvePolicy({ threshold: 0.5 })` merges with defaults
   - Test `resolvePolicy(null)` returns full defaults (null treated as empty)
   - Test `resolvePolicy(undefined)` returns full defaults
   - Test `resolvePolicy({ threshold: 1.1 })` throws (out of range)
   - Test `resolvePolicy({ threshold: -0.1 })` throws (out of range)
   - Test `resolvePolicy({ preserveRecentCount: -1 })` throws (negative)
   - Test `resolvePolicy({ preserveRecentCount: 1.5 })` throws (not integer)
   - Test `DEFAULT_POLICY` equals `{ threshold: 0.8, preserveRecentCount: 10, enabled: true }`
   - Import from `"./policy.js"`

3. Add tests to existing `src/repositories/context.repository.test.ts`:
   Add a new `describe("policyConfig")` block with:
   - Test: create context with policyConfig, findById returns it
     ```typescript
     const ctx = await repository.create({
       name: "With Policy",
       policyConfig: { threshold: 0.6, preserveRecentCount: 5, enabled: false },
     });
     const found = await repository.findById(ctx.id);
     expect(found?.policyConfig).toEqual({ threshold: 0.6, preserveRecentCount: 5, enabled: false });
     ```
   - Test: create context without policyConfig, findById returns null policyConfig
     ```typescript
     const ctx = await repository.create({ name: "No Policy" });
     const found = await repository.findById(ctx.id);
     expect(found?.policyConfig).toBeNull();
     ```
   - Test: create context with partial policy (pre-resolved via resolvePolicy), verify full config stored
     ```typescript
     import { resolvePolicy } from "../validation/policy.js";
     const policy = resolvePolicy({ threshold: 0.5 });
     const ctx = await repository.create({ name: "Partial", policyConfig: policy });
     const found = await repository.findById(ctx.id);
     expect(found?.policyConfig).toEqual({ threshold: 0.5, preserveRecentCount: 10, enabled: true });
     ```

4. Run full test suite:
   ```bash
   pnpm test
   ```
   All tests must pass including existing ones.

5. Run coverage check:
   ```bash
   pnpm test:coverage
   ```
   Coverage must meet the existing 100% threshold.
  </action>
  <verify>
    - `pnpm test` passes with all new and existing tests green
    - `pnpm test:coverage` meets coverage threshold
    - `pnpm lint` passes
  </verify>
  <done>
    - Token counting tests verify consistent integer results
    - Policy validation tests verify defaults, merging, and boundary enforcement
    - Repository tests verify policyConfig persists on create and returns on findById
    - Null policyConfig for contexts created without policy
    - All tests pass, coverage maintained
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` compiles with zero errors
2. `pnpm test` passes all tests (existing + new)
3. `pnpm test:coverage` meets 100% threshold
4. `pnpm lint` passes
5. Phase 6 success criteria verified:
   - Token counting returns consistent results for messages using gpt-tokenizer
   - Context can be created with custom policy configuration that persists across retrieval
   - Context without explicit policy configuration receives default policy values (via resolvePolicy)
   - Policy configuration includes all required fields (threshold, preserveRecentCount, enabled)
</verification>

<success_criteria>
- CreateContextInput accepts optional PolicyConfig
- ContextRepository.create() persists policyConfig to JSONB column
- createContextSchema validates policyConfig in API layer
- Token counting, policy validation, and policy persistence all tested
- 100% coverage maintained
- All Phase 6 requirements (INFRA-01 through POLICY-03) satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/pending/06-infrastructure-policy-foundation/06-02-SUMMARY.md`
</output>
