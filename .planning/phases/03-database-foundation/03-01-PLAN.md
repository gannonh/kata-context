---
phase: 03-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - pnpm-lock.yaml
  - drizzle.config.ts
  - src/db/client.ts
  - src/db/schema/index.ts
  - src/db/schema/contexts.ts
  - src/db/schema/messages.ts
  - .env.example
autonomous: true
user_setup:
  - service: neon
    why: "PostgreSQL database hosting with pgvector"
    env_vars:
      - name: DATABASE_URL
        source: "Neon Console -> Connection Details -> Connection string (pooled, with -pooler hostname)"
    dashboard_config:
      - task: "Create Neon project and database"
        location: "Neon Console -> New Project"
      - task: "Enable pgvector extension"
        location: "Neon Console -> SQL Editor -> Run: CREATE EXTENSION IF NOT EXISTS vector;"

must_haves:
  truths:
    - "Drizzle ORM compiles with full TypeScript type inference"
    - "Schema defines contexts table with all required columns"
    - "Schema defines messages table with all required columns including vector(1536)"
    - "Connection client uses pooled endpoint and Vercel Fluid lifecycle"
  artifacts:
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration"
      contains: "defineConfig"
    - path: "src/db/client.ts"
      provides: "Database client with connection pooling"
      exports: ["db", "pool"]
    - path: "src/db/schema/contexts.ts"
      provides: "Contexts table definition"
      contains: "pgTable"
    - path: "src/db/schema/messages.ts"
      provides: "Messages table definition with embedding vector"
      contains: "vector"
  key_links:
    - from: "src/db/client.ts"
      to: "src/db/schema/index.ts"
      via: "schema import"
      pattern: "import.*schema"
    - from: "drizzle.config.ts"
      to: "src/db/schema"
      via: "schema path"
      pattern: "schema.*src/db/schema"
---

<objective>
Install Drizzle ORM with Neon serverless driver and define complete database schema for contexts and messages tables.

Purpose: Establishes the type-safe database layer foundation that all subsequent data access will build upon.
Output: Compiled Drizzle schema with contexts and messages tables, ready for migration generation.
</objective>

<execution_context>
<!-- Executor agent has built-in instructions for plan execution and summary creation -->
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/SUMMARY.md

# Existing codebase patterns
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install database dependencies</name>
  <files>package.json, pnpm-lock.yaml</files>
  <action>
Install required packages with exact versions from research:

```bash
pnpm add drizzle-orm@0.45.1 pg@8.14.1 @vercel/functions@2.1.0
pnpm add -D drizzle-kit@0.31.8 @types/pg@8.15.2
```

Dependencies:
- drizzle-orm: Type-safe ORM
- drizzle-kit: Migration tooling (dev only)
- pg: PostgreSQL driver for Node.js serverless functions
- @vercel/functions: Provides attachDatabasePool for connection lifecycle
- @types/pg: TypeScript types for pg

Note: Using pg driver (not @neondatabase/serverless) because we're targeting Vercel Serverless Functions (Node.js runtime), not Edge Functions. The pg driver with pooled Neon connection string is the correct choice per research.

Add npm scripts to package.json:
- "db:generate": "drizzle-kit generate"
- "db:migrate": "drizzle-kit migrate"
- "db:push": "drizzle-kit push" (development only)
- "db:studio": "drizzle-kit studio"
  </action>
  <verify>
`pnpm list drizzle-orm pg @vercel/functions` shows installed versions.
`pnpm list -D drizzle-kit @types/pg` shows dev dependencies.
`pnpm run db:generate --help` executes without error.
  </verify>
  <done>All database packages installed, npm scripts for db:generate and db:migrate available.</done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle configuration and database client</name>
  <files>drizzle.config.ts, src/db/client.ts, .env.example</files>
  <action>
Create drizzle.config.ts at project root:
```typescript
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema/index.ts",
  out: "./src/db/migrations",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
  verbose: true,
  strict: true,
});
```

Create src/db/client.ts with Vercel Fluid-optimized connection pooling:
```typescript
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import { attachDatabasePool } from "@vercel/functions";
import * as schema from "./schema/index.js";

const connectionString = process.env.DATABASE_URL;

if (!connectionString) {
  throw new Error("DATABASE_URL environment variable is required");
}

// Verify pooled connection string (must contain -pooler)
if (!connectionString.includes("-pooler")) {
  console.warn(
    "WARNING: DATABASE_URL does not contain -pooler. Use pooled connection string for serverless."
  );
}

// Conservative pool settings for serverless
// Per research: keep pool small (2-3) to avoid exhaustion under Vercel Fluid scaling
const pool = new Pool({
  connectionString,
  max: 3,
  idleTimeoutMillis: 5000,
  connectionTimeoutMillis: 10000,
});

// Vercel Fluid lifecycle management - ensures connections close before function suspension
attachDatabasePool(pool);

export const db = drizzle(pool, { schema });
export { pool };
```

Create .env.example documenting required variables:
```
# Database connection (use pooled endpoint with -pooler hostname)
# Format: postgresql://user:password@ep-xxx-pooler.region.aws.neon.tech/dbname?sslmode=require
DATABASE_URL=
```
  </action>
  <verify>
`pnpm run build` compiles without TypeScript errors.
`ls src/db/client.ts drizzle.config.ts .env.example` shows all files exist.
  </verify>
  <done>Drizzle config and client created with Vercel Fluid connection pooling pattern.</done>
</task>

<task type="auto">
  <name>Task 3: Define Drizzle schema for contexts and messages tables</name>
  <files>src/db/schema/index.ts, src/db/schema/contexts.ts, src/db/schema/messages.ts</files>
  <action>
Create src/db/schema/contexts.ts:
```typescript
import { pgTable, uuid, text, timestamp, integer, bigint } from "drizzle-orm/pg-core";

export const contexts = pgTable("contexts", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name"),
  createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp("updated_at", { withTimezone: true }).notNull().defaultNow(),
  messageCount: integer("message_count").notNull().default(0),
  totalTokens: integer("total_tokens").notNull().default(0),
  latestVersion: bigint("latest_version", { mode: "number" }).notNull().default(0),
  parentId: uuid("parent_id").references(() => contexts.id),
  forkVersion: bigint("fork_version", { mode: "number" }),
  deletedAt: timestamp("deleted_at", { withTimezone: true }),
});

export type Context = typeof contexts.$inferSelect;
export type NewContext = typeof contexts.$inferInsert;
```

Create src/db/schema/messages.ts with pgvector support:
```typescript
import { pgTable, uuid, text, timestamp, integer, bigint, index, unique } from "drizzle-orm/pg-core";
import { vector } from "drizzle-orm/pg-core";
import { contexts } from "./contexts.js";

export const messages = pgTable(
  "messages",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    contextId: uuid("context_id")
      .notNull()
      .references(() => contexts.id),
    version: bigint("version", { mode: "number" }).notNull(),
    createdAt: timestamp("created_at", { withTimezone: true }).notNull().defaultNow(),
    role: text("role").notNull(), // 'user' | 'assistant' | 'system' | 'tool'
    content: text("content").notNull(),
    toolCallId: text("tool_call_id"),
    toolName: text("tool_name"),
    tokenCount: integer("token_count"),
    model: text("model"),
    deletedAt: timestamp("deleted_at", { withTimezone: true }),
    // pgvector column for semantic search (v0.3.0+)
    // 1536 dimensions = OpenAI text-embedding-3-small
    embedding: vector("embedding", { dimensions: 1536 }),
  },
  (table) => [
    // Index for efficient message retrieval by context and version order
    index("messages_context_version_idx").on(table.contextId, table.version),
    // Index for soft delete filtering
    index("messages_deleted_at_idx").on(table.deletedAt),
    // Unique constraint: one version per context
    unique("messages_context_version_unique").on(table.contextId, table.version),
  ]
);

export type Message = typeof messages.$inferSelect;
export type NewMessage = typeof messages.$inferInsert;
```

Create src/db/schema/index.ts to export all schema:
```typescript
export * from "./contexts.js";
export * from "./messages.js";
```
  </action>
  <verify>
`pnpm run build` compiles without TypeScript errors.
TypeScript shows proper type inference: `Context`, `NewContext`, `Message`, `NewMessage` types are available.
Schema files export pgTable definitions with all required columns per SCHEMA-01 through SCHEMA-04.
  </verify>
  <done>Complete Drizzle schema with contexts table, messages table (including vector column), and indexes defined.</done>
</task>

</tasks>

<verification>
After all tasks:
1. `pnpm run build` succeeds with no TypeScript errors
2. `pnpm run db:generate --help` shows drizzle-kit is working
3. All schema files exist: `ls src/db/schema/*.ts`
4. Client file exports db and pool: `grep -E "export.*(db|pool)" src/db/client.ts`
5. Schema includes vector type: `grep "vector" src/db/schema/messages.ts`
</verification>

<success_criteria>
- drizzle-orm, pg, @vercel/functions installed as dependencies
- drizzle-kit installed as dev dependency
- drizzle.config.ts configured for PostgreSQL with schema path
- src/db/client.ts exports `db` and `pool` with Vercel Fluid lifecycle
- src/db/schema/contexts.ts defines contexts table with all columns from SCHEMA-01
- src/db/schema/messages.ts defines messages table with all columns from SCHEMA-02, SCHEMA-03
- Indexes defined per SCHEMA-04 (context_id + version, deleted_at)
- TypeScript compilation succeeds with full type inference
</success_criteria>

<output>
After completion, create `.planning/phases/03-database-foundation/03-01-SUMMARY.md`
</output>
